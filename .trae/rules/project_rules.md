# 项目概况

- 项目名称：Web Chaos
- 项目描述：一个基于 Vue 3 的 Web 应用模板，主要用于后台管理类项目。
- 项目仓库：[https://github.com/liushuxue/web-chaos]

# 项目技术栈

- 前端框架：Vue 3
- 组件库：Element Plus
- 样式库：Tailwind CSS
- 路由：Vue Router
- 状态管理：Pinia
- 构建工具：Vite
- 代码规范：ESLint + Prettier
- 包管理器：pnpm

# 项目目录结构

- src/
  - api/ API 模块- 应用的 API 模块
  - assets/ 资源文件- 静态资源文件，如图片、字体等
  - components/ 组件- 可复用的 Vue 组件
  - constants/ 常量- 应用的常量模块
  - directives/ 指令- 应用的指令模块
  - hooks/ composable- 应用的可组合函数模块
  - layouts/ 布局- 页面布局组件
  - plugins/ 插件- 应用的插件
  - router/ 路由- Vue Router 配置文件
  - store/ 状态管理- Pinia 状态管理模块
  - styles/ 样式- 全局样式文件
  - types/ 类型- 应用的类型定义模块
  - utils/ 工具- 应用的工具函数
  - views/ 页面- 应用的页面组件
  - App.vue 应用入口- 应用的根组件
  - main.js 应用初始化- 应用的入口文件
- .trae/ 项目配置- 项目的配置文件
- .eslint.config.mjs ESLint 配置- ESLint 配置文件
- .prettierrc.js Prettier 配置- Prettier 配置文件
- index.html 应用入口 HTML- 应用的入口 HTML 文件
- package.json 项目依赖- 项目的依赖配置文件
- vite.config.js Vite 配置- Vite 配置文件
- tsconfig.json TypeScript 配置- TypeScript 配置文件
- README.md 项目说明- 项目的说明文档

# 核心约定

- 命令行工具：使用 pnpm 作为包管理器，所有命令都应通过 pnpm 执行。
- 模块化：与一个主要功能相关的 API、Store、Type 应放在一起或在同名模块下。
- 组件化：每个功能或页面都应对应一个 Vue 组件，组件应保持简洁、可复用。
- 目录命名：使用短横线分隔命名（kebab-case），避免下划线或驼峰命名。
- 文件命名：组件使用 PascalCase，其他文件（composables, utils, stores）使用 camelCase。
- 组件命名：多词命名，避免与 HTML 元素冲突，例如 UserCard.vue。
- 布局组件：用于页面布局的组件，应放在 layouts/ 目录下。
- 视图组件：
  - 用于展示数据或处理用户交互的组件，应放在 views/ 目录下 ，
  - 组件采用 文件名/组件名.vue 格式 使用index.ts 默认导出组件 及 导出类型定义。
  - 组件内拆分出来的子组件放在 ./components/ 目录下。
- 功能组件：
  - 具有独立功能的组件，可在多个视图组件中复用，应放在 components/ 目录下，
  - 组件采用 文件名/src/组件名.vue 格式 使用index.ts 导出组件 及 类型定义。

- 组件样式：
  - 优先使用 Tailwind CSS 类名，
  - 在修改 element-plus 组件样式时，使用自定义样式。

# ✅ 能做 & 应该做

## 代码生成与自动完成

- 根据上下文生成代码：在现有文件内，根据函数名、注释和已有代码风格，生成逻辑连贯的代码片段。
- 补全重复性代码：例如，根据 interface 定义快速生成 Pinia Store 的初始结构，或根据模板快速生成 @click 处理函数。
- 生成工具函数：在 utils/ 目录下，根据明确的需求描述生成纯函数，并附带 JSDoc 注释和类型定义。

## 代码解释与注释

- 解释复杂代码块：当开发者遇到不理解的代码时，要求 AI 解释其功能。
- 生成 JSDoc 注释：为函数、组件生成标准的文档注释。
- 添加代码行内注释：为复杂的算法或业务逻辑添加简明注释。

## 代码重构与优化

- 函数提取：将内联逻辑提取为独立的、可复用的 Composable 或工具函数。
- 重命名：安全地重命名变量、函数、文件（需在 IDE 内通过重构工具完成，AI 仅提供建议）。
- 语法优化：将 Options API 转换为 Composition API，或将冗余代码简化为更现代、简洁的写法。

## 问题诊断与修复

- 定位语法错误：快速指出 ESLint 或 TypeScript 编译错误的原因。
- 修复常见 bug：例如，解决 v-for 中缺少 key 的问题，或修复响应式数据更新不触发渲染的问题。
- 提出修复建议：对于运行时错误，根据错误信息提供可能的修复方案。

# 绝对不能做 以下行为被严格禁止，AI 的此类建议应被立即拒绝：

## 架构与依赖决策

- 禁止引入新的第三方库。除非经过团队技术评审，否则 AI 不得建议安装 npm 包来解决问题。
- 禁止提议改变项目核心架构。例如，不得建议用新的状态管理库替换 Pinia，或用新的构建工具替换 Vite。

## 业务逻辑定义

- 禁止自行发明或猜测业务规则。AI 必须基于开发者提供的明确需求和现有代码上下文来编写逻辑。

## 安全与敏感操作

- 禁止编写任何涉及安全逻辑的代码。例如，身份认证、权限验证、数据加密、密钥处理等。这些必须由人类开发者亲自编写和审查。
- 禁止在代码中硬编码任何敏感信息，如 API Keys、密码、令牌。

## 大规模自动化

- 禁止在没有人类逐文件审查的情况下，进行全项目范围的自动化重构。
- 禁止执行无法被 IDE 的 git diff 清晰跟踪的批量文件操作。

# 需求规范 6A

## Align（需求对齐）‌

- 明确AI能力边界（如“需依赖外部数据”或“需模型微调”）
- 输出《需求对齐清单》，包含AI能力矩阵、数据需求清单和验收标准
- 工具推荐：Miro（需求可视化）、飞书多维表格（数据跟踪）

## Architect（架构设计）‌

- 分层解耦：分为感知层（数据输入）、决策层（模型推理）、执行层（结果输出）
- 优先复用成熟组件（如Triton模型服务框架）
- 交付物：DESIGN\*任务名.md（含架构图、数据流向图）

## Atomize（任务拆分）‌

- 拆分标准：独立可验证（如“数据标注任务”输入原始图像，输出带标签的JSON文件）
- 工时可控：常规任务1-8小时/个，复杂任务拆分为子任务
- 依赖清晰：标注数据依赖和技术依赖，避免循环依赖
- 交付物：ATOMIZE\*任务名.md（含任务清单、工时估计）

## Approve（方案审批）‌

- 审查重点：数据合规性（如标注准确率≥95%）、模型可行性（如GPU显存≥24G）
- 风险预案：对模型精度不达标等问题明确替代方案
- 交付物：APPROVE\*任务名.md（含评审意见、风险清单）

## Automate（自动化实施）‌

- 自动化范围：数据清洗（Airflow调度）、模型训练（MLflow跟踪）、服务部署（CI/CD流水线）
- 执行规范：代码风格统一（ESLint/Pylint）、文档与代码同步更新
- 交付物：AUTOMATE\*任务名.md（含执行计划、监控指标）

## Assess（交付评估）‌

- 评估指标：
  - 模型性能：核心任务准确率≥90%（进阶≥95%）
  - 服务性能：API响应延时≤500ms（进阶≥100QPS）
- 交付物：ASSESS\*任务名.md（含评估报告、运维计划）
